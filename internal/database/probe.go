package database

import (
	"encoding/binary"
	"encoding/json"
	"fmt"

	"github.com/boltdb/bolt"
	"github.com/madjlzz/madprobe/internal/model"
)

type probeDto struct {
	ID    int
	Name  string
	URL   string
	Delay uint
}

func newProbeModel(probe model.Probe) *probeDto {
	// ID is generated by bold db
	// Status and Finish chan not persisted
	return &probeDto{
		Name:  probe.Name,
		URL:   probe.URL,
		Delay: probe.Delay,
	}
}

func (p *probeDto) toProbe() model.Probe {
	return model.Probe{
		Name:  p.Name,
		URL:   p.URL,
		Delay: p.Delay,
		ID:    p.ID,
	}
}

// InsertProbe returns saved probe (with updated ID) and error. Executes onSuccess with inserted probe as part of the transaction.
func (c *client) InsertProbe(probe model.Probe, onSuccess func(probe model.Probe) error) (model.Probe, error) {
	var probeModel = newProbeModel(probe)
	err := c.db.Update(func(tx *bolt.Tx) error {
		b := tx.Bucket([]byte(probeBucket))
		id, _ := b.NextSequence()
		probeModel.ID = int(id)
		buf, err := json.Marshal(probeModel)
		if err != nil {
			return err
		}
		err = b.Put(itob(id), buf)
		if err != nil {
			return err
		}
		return onSuccess(probeModel.toProbe())
	})
	if err != nil {
		return probeModel.toProbe(), fmt.Errorf("failed to insert probe: %w", err)
	}
	return probeModel.toProbe(), nil
}

// DeleteProbe delete probe y ID, returns nil error on success.  Executes onSuccess with deleted probe as part of the transaction.
func (c *client) DeleteProbeByID(probeID int, onSuccess func() error) error {
	err := c.db.Update(func(tx *bolt.Tx) error {
		b := tx.Bucket([]byte(probeBucket))
		err := b.Delete(itob(uint64(probeID)))
		if err != nil {
			return err
		}
		return onSuccess()
	})
	if err != nil {
		return fmt.Errorf("failed to delete probe: %w", err)
	}
	return nil
}

// ReadAllProbes returns all probes in database
func (c *client) ReadAllProbes() ([]model.Probe, error) {
	var probes []model.Probe
	err := c.db.View(func(tx *bolt.Tx) error {
		b := tx.Bucket([]byte(probeBucket))
		return b.ForEach(func(_, probeStored []byte) error {
			var pDto probeDto
			err := json.Unmarshal(probeStored, &pDto)
			if err != nil {
				return err
			}
			probes = append(probes, pDto.toProbe())
			return nil
		})
	})
	if err != nil {
		return nil, fmt.Errorf("failed to read all probes: %w", err)
	}
	return probes, nil
}

func itob(v uint64) []byte {
	b := make([]byte, 8)
	binary.BigEndian.PutUint64(b, uint64(v))
	return b
}
